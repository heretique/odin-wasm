package shdc

import "core:fmt"
import str "core:strings"
import "core:os"
import "core:mem"

write :: str.write_string

output_header: string : `/*

! This file is generated by the shader compiler. Do not edit it manually. !

*/

package example

import gl  "../wasm/webgl"


`

file_buffer: [mem.Megabyte]byte

main :: proc() {
	context.allocator = context.temp_allocator

	b := str.builder_make_len_cap(0, 10000)
	write(&b, output_header)

	dir_handle, open_err := os.open("example")
	if open_err != 0 {
		panic("failed to open directory")
	}

	file_infos, read_err := os.read_dir(dir_handle, -1)
	if read_err != 0 {
		panic("failed to read directory")
	}

	for fi in file_infos {
		if fi.is_dir do continue

		shader_kind: Shader_Kind
		shader_name_suffix: string
		
		switch fi.name[max(0, len(fi.name)-5):] {
		case ".vert":
			shader_kind = .Vert
			shader_name_suffix = "_vert"
		case ".frag":
			shader_kind = .Frag
			shader_name_suffix = "_frag"
		case: continue
		}

		shader_name := str.concatenate({fi.name[:len(fi.name)-5], shader_name_suffix})
		shader_name_snake := str.to_snake_case(shader_name)
		shader_name_ada   := str.to_ada_case  (shader_name)

		file_handle, _ := os.open(fi.fullpath)
		file_len, read_err := os.read(file_handle, file_buffer[:])
		if read_err != 0 {
			fmt.panicf("failed to read file: %s\n", fi.fullpath)
		}

		defer {
			os.close(file_handle)
			mem.zero_slice(file_buffer[:file_len])
		}

		file_text := string(file_buffer[:file_len])
		inputs, err := shader_get_inputs(file_text, shader_kind)
		if err != nil {
			fmt.panicf("error: %v\n", err)
		}

		/* Type */
		write(&b, "Inputs_")
		write(&b, shader_name_ada)
		write(&b, " :: struct {\n")
		
		for input in inputs {
			write(&b, "\t")
			write(&b, input.name)
			write(&b, ": ")
			if input.len > 1 {
				write(&b, "[")
				str.write_int(&b, input.len)
				write(&b, "]")
			}
			write(&b, input.kind == .Uniform ? "Uniform_" : "Attribute_")
			write(&b, input.type)
			write(&b, ",\n")
		}

		write(&b, "}\n\n")

		/* Locations */
		write(&b, "input_locations_")
		write(&b, shader_name_snake)
		write(&b, " :: proc(s: ^Inputs_")
		write(&b, shader_name_ada)
		write(&b, ", program: gl.Program) {\n")

		for input in inputs {
			if input.len == 0 {
				write(&b, "\ts.")
				write(&b, input.name)
				write(&b, " = ")
				write(&b, input.kind == .Uniform ? "uniform_location_" : "attribute_location_")
				write(&b, input.type)
				write(&b, "(program, \"")
				write(&b, input.name)
				write(&b, "\")\n")
			} else {
				for i in 0..<input.len {
					write(&b, "\ts.")
					write(&b, input.name)
					write(&b, "[")
					str.write_int(&b, i)
					write(&b, "] = ")
					write(&b, input.kind == .Uniform ? "uniform_location_" : "attribute_location_")
					write(&b, input.type)
					write(&b, "(program, \"")
					write(&b, input.name)
					write(&b, "[")
					str.write_int(&b, i)
					write(&b, "]\")\n")
				}
			}
		}

		write(&b, "}\n\n")
	}

	ok := os.write_entire_file("example/shaders_generated.odin", b.buf[:])
	if !ok {
		fmt.printf("failed to write file\n")
	}

	os.exit(0)
}
